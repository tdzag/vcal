<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="NARA Tadahisa">

<title>ベクトル解析</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<meta name="robots" content="noindex, nofollow">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="1">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#表記" id="toc-表記" class="nav-link active" data-scroll-target="#表記"><span class="header-section-number">0.1</span> 表記</a></li>
  <li><a href="#ベクトル" id="toc-ベクトル" class="nav-link" data-scroll-target="#ベクトル"><span class="header-section-number">0.2</span> ベクトル</a>
  <ul>
  <li><a href="#足し算スカラー倍" id="toc-足し算スカラー倍" class="nav-link" data-scroll-target="#足し算スカラー倍">足し算・スカラー倍</a></li>
  <li><a href="#内積" id="toc-内積" class="nav-link" data-scroll-target="#内積">内積</a></li>
  <li><a href="#クロス積ベクトル積" id="toc-クロス積ベクトル積" class="nav-link" data-scroll-target="#クロス積ベクトル積">クロス積（ベクトル積）</a></li>
  </ul></li>
  <li><a href="#次元空間での曲線曲面" id="toc-次元空間での曲線曲面" class="nav-link" data-scroll-target="#次元空間での曲線曲面"><span class="header-section-number">0.3</span> ３次元空間での曲線・曲面</a>
  <ul>
  <li><a href="#曲線" id="toc-曲線" class="nav-link" data-scroll-target="#曲線">曲線</a></li>
  <li><a href="#曲面" id="toc-曲面" class="nav-link" data-scroll-target="#曲面">曲面</a></li>
  </ul></li>
  <li><a href="#微分積分" id="toc-微分積分" class="nav-link" data-scroll-target="#微分積分"><span class="header-section-number">0.4</span> 微分積分</a>
  <ul>
  <li><a href="#スカラー場ベクトル場-scalar-field-vector-field" id="toc-スカラー場ベクトル場-scalar-field-vector-field" class="nav-link" data-scroll-target="#スカラー場ベクトル場-scalar-field-vector-field">スカラー場・ベクトル場 (scalar field, vector field)</a></li>
  <li><a href="#スカラー場ベクトル場の微分" id="toc-スカラー場ベクトル場の微分" class="nav-link" data-scroll-target="#スカラー場ベクトル場の微分">スカラー場・ベクトル場の微分</a></li>
  <li><a href="#スカラー場ベクトル場の積分" id="toc-スカラー場ベクトル場の積分" class="nav-link" data-scroll-target="#スカラー場ベクトル場の積分">スカラー場・ベクトル場の積分</a></li>
  </ul></li>
  <li><a href="#微分形式" id="toc-微分形式" class="nav-link" data-scroll-target="#微分形式"><span class="header-section-number">0.5</span> 微分形式</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ベクトル解析</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>NARA Tadahisa </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<!-- 
Setting:
break on single new line: False

In config.js:
{
  katexConfig: {
  "macros": {"\\RR": "\\mathbb{R}"}
}


In style.less:
.markdown-preview.markdown-preview {
  // modify your style here
  // eg: background-color: blue;
  font-size: 14px;
}
 -->
<!-- 
For Markdown Extended: 
https://www.mybyways.com/blog/customizing-vs-code-for-markdown-note-taking
 -->
<div class="hidden">

</div>
<!-- $$
\def\half#1{\frac{#1}{2}}$$ 
-->
<!-- 
$$
\gdef\RR{\mathbb{R}}
\gdef\CC{\mathbb{C}}
\gdef\HH{\mathbb{H}}
$$ 
-->
<!-- $$\def\RR{\mathbb{R}}$$ -->
<!-- $$
\renewcommand{\vec}[1]{\mathbf{#1}}$$ 
-->
<!-- 
!!! quote quote
!!! done done, success
!!! info info, todo
!!! tip tip, hint
::: callout-note note
!!! summary summary
!!! question question
!!! fail fail
::: {.callout-warning} warning
!!! danger danger
!!! error error
 -->
<!-- 
:gem: gem

:snowflake: snowflake

:sparkles: sparkles

:memo: memo

:notes: notes

:warning: warning

:thinking: :cry: :sob: :hugs:  :key:
 -->
<!-- Test: $\RR$ -->
<!-- {% include file.md %} -->
<!-- {{ include 'file.md' }} -->
<!-- [[TOC]] -->
<section id="表記" class="level3" data-number="0.1">
<h3 data-number="0.1" class="anchored" data-anchor-id="表記"><span class="header-section-number">0.1</span> 表記</h3>
<p><span class="math inline">\mathbb{R}</span>: 実数全体の集合</p>
<!-- $\CC$: 複素数全体の集合 (complex numbers) -->
<p><span class="math inline">\mathbb{R}^n</span>: <span class="math inline">n</span> 次元空間（正確には、実ユークリッド空間）</p>
</section>
<section id="ベクトル" class="level3" data-number="0.2">
<h3 data-number="0.2" class="anchored" data-anchor-id="ベクトル"><span class="header-section-number">0.2</span> ベクトル</h3>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
定義：ベクトル、スカラー
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>ベクトル</strong>: 向きと大きさから成るデータ<br>
<strong>スカラー</strong>: １つの数から成るデータ（多くの場合ベクトルに掛ける倍率のようなものを想定している）</p>
<p>また <span class="math inline">\bm{v}</span> をベクトルとしたとき、<span class="math inline">|\bm{v}|</span> で <span class="math inline">\bm{v}</span> の大きさを表す。</p>
</div>
</div>
<p>空間内において速度や力を考える際、その大きさのデータだけでは不便なことも多い。 そのようなときベクトルを使うと便利である。</p>
<!-- $\pmb{x}, x, \bm{x}$ -->
<p>具体的なベクトルは数の列で表すことができる：</p>
<p>例：ベクトル <span class="math inline">\bm{v}=(1,2,3)</span>. <a href="fig/a_vector.html" target="_blank">（イメージ）</a></p>
<p>これは３次元空間 <span class="math inline">\mathbb{R}^3</span>において、以下のベクトルを意味する。</p>
<ul>
<li>向き：原点 <span class="math inline">(0,0,0)</span> から点 <span class="math inline">(1,2,3)</span> に向かう向き</li>
<li>大きさ：<span class="math inline">\sqrt{1^2+2^2+3^2}</span></li>
</ul>
<p>このように、<span class="math inline">n</span>次元空間の任意のベクトルは、 <span class="math inline">n</span>次元空間の点と１対１で対応しているので、 <span class="math inline">\bm{v}</span> が <span class="math inline">n</span>次元空間のベクトルであることを <span class="math display">
\bm{v} \in \mathbb{R}^n
</span> と書くことも多い。</p>
<section id="足し算スカラー倍" class="level4">
<h4 class="anchored" data-anchor-id="足し算スカラー倍">足し算・スカラー倍</h4>
<p>ベクトルには、普通の数と類似な演算が定義されている。</p>
<p><strong>足し算</strong>（ベクトル＋ベクトル）</p>
<ul>
<li><p><span class="math inline">\bm{v}=(1,2,3),\ \bm{w}=(6,5,4)</span> のとき</p>
<p><span class="math inline">\bm{v} + \bm{w} =(1+6, 2+5, 3+4)=(7,7,7).</span> <a href="fig/v+w_vector.html" target="_blank">（イメージ）</a></p></li>
</ul>
<p><strong>スカラー倍</strong>（ベクトル×スカラー）</p>
<ul>
<li><p><span class="math inline">\bm{v}=(1,2,3)</span> のとき</p>
<p><span class="math inline">3\bm{v}=(3,6,9),\ -2\bm{v}=(-2,-4,-6).</span></p></li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
定義：基本単位ベクトル
</div>
</div>
<div class="callout-body-container callout-body">
<p>本稿に出てくる <span class="math inline">\mathbf{i}, \mathbf{j}, \mathbf{k}</span> （太字）は、特に断らない限り、以下のように定義されているベクトルとする。 <span class="math display">
\mathbf{i} = (1,0,0),\quad \mathbf{j}=(0,1,0),\quad \mathbf{k}=(0,0,1).
</span> 文献によっては、代わりに以下の表記を使うこともある。 <span class="math display">
\mathbf{e}_1 = (1,0,0),\quad \mathbf{e}_2=(0,1,0),\quad \mathbf{e}_3=(0,0,1).
</span></p>
</div>
</div>
<!--
    $$\frac{\partial}{\partial x} = (1,0,0),\quad \frac{\partial}{\partial y} =(0,1,0),\quad \frac{\partial}{\partial z} =(0,0,1).$$
-->
<p>これを使うと <span class="math inline">\bm{w}=(4,-5,6)</span> は <span class="math display">
\bm{w} = 4\mathbf{i} -5\mathbf{j} +6\mathbf{k}
</span> と表せる。</p>
<hr>
<p>スカラー倍はベクトルとスカラーの積であったが、 ベクトルとベクトルの積の積もある。 主なものは以下の内積とクロス積である。</p>
</section>
<section id="内積" class="level4">
<h4 class="anchored" data-anchor-id="内積">内積</h4>
<ul>
<li><span class="math inline">\bm{v}=(1,2,3)</span>, <span class="math inline">\bm{w}=(4,5,6)</span> のとき<br>
<span class="math inline">\bm{v}\cdot\bm{w}=1\cdot4+2\cdot5+3\cdot6=32.</span>
<table align="center" style="background-color: #f2f2f2; color: #333;">
<thead>
<tr>
<th>
<span class="math inline">\bm{v}</span>
</th>
<th>
<span class="math inline">=</span>
</th>
<th>
<span class="math inline">(</span>
</th>
<th>
<span class="math inline">1</span>
</th>
<th>
<span class="math inline">,</span>
</th>
<th>
<span class="math inline">2</span>
</th>
<th>
<span class="math inline">,</span>
</th>
<th>
<span class="math inline">3</span>
</th>
<th>
<span class="math inline">)</span>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
<span class="math inline">\vdots</span>
</td>
<td>
</td>
<td>
<span class="math inline">\vdots</span>
</td>
<td>
</td>
<td>
<span class="math inline">\vdots</span>
</td>
<td>
</td>
</tr>
<tr>
<td>
<span class="math inline">\bm{w}</span>
</td>
<td>
<span class="math inline">=</span>
</td>
<td>
<span class="math inline">(</span>
</td>
<td>
<span class="math inline">4</span>
</td>
<td>
<span class="math inline">,</span>
</td>
<td>
<span class="math inline">5</span>
</td>
<td>
<span class="math inline">,</span>
</td>
<td>
<span class="math inline">6</span>
</td>
<td>
<span class="math inline">)</span>
</td>
</tr>
</tbody>
</table></li>
</ul>
</section>
<section id="クロス積ベクトル積" class="level4">
<h4 class="anchored" data-anchor-id="クロス積ベクトル積">クロス積（ベクトル積）</h4>
<ul>
<li><span class="math inline">\bm{v}=(1,2,3)</span>, <span class="math inline">\bm{w}=(4,5,6)</span> のとき<br>
<span class="math inline">\bm{v}\times \bm{w}=(2\cdot6-3\cdot5,\ 3\cdot4-1\cdot6,\ 1\cdot5-2\cdot4).</span>
<table align="center" style="background-color: #f2f2f2; color: #333;">
<thead>
<tr>
<th>
<span class="math inline">\bm{v}</span>
</th>
<th>
<span class="math inline">=</span>
</th>
<th>
<span class="math inline">(</span>
</th>
<th>
<span class="math inline">1</span>
</th>
<th>
<span class="math inline">,</span>
</th>
<th>
<span class="math inline">2</span>
</th>
<th>
<span class="math inline">,</span>
</th>
<th>
<span class="math inline">3</span>
</th>
<th>
<span class="math inline">)</span>
</th>
<th>
<span class="math inline">(</span>
</th>
<th>
<span class="math inline">1</span>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
</td>
<td>
<span class="math inline">\times</span>
</td>
<td>
</td>
<td>
<span class="math inline">\times</span>
</td>
<td>
</td>
<td>
<span class="math inline">\times</span>
</td>
<th>
</th>
<th>
</th>
</tr>
<tr>
<td>
<span class="math inline">\bm{w}</span>
</td>
<td>
<span class="math inline">=</span>
</td>
<td>
<span class="math inline">(</span>
</td>
<td>
<span class="math inline">4</span>
</td>
<td>
<span class="math inline">,</span>
</td>
<td>
<span class="math inline">5</span>
</td>
<td>
<span class="math inline">,</span>
</td>
<td>
<span class="math inline">6</span>
</td>
<td>
<span class="math inline">)</span>
</td>
<th>
<span class="math inline">(</span>
</th>
<th>
<span class="math inline">4</span>
</th>
</tr>
</tbody>
</table></li>
</ul>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
注意：普通の掛け算と違う
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math display">\bm{v}\times \bm{w} = - \bm{w}\times \bm{v}.</span></p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
行列式表示
</div>
</div>
<div class="callout-body-container callout-body">
<p>クロス積の行列式表示 <span class="math inline">\bm{v}=(v_1,v_2,v_3),\ \bm{w}=(w_1,w_2,w_3)</span> とすると、そのクロス積は行列式を使って表示できる。 <span class="math display">
    \begin{align*}
    \bm{v}\times \bm{w}
    = \left| \begin{matrix}
    \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k}\\
    v_1 &amp; v_2 &amp; v_3\\
    w_1 &amp; w_2 &amp; w_3
    \end{matrix} \right|
    \end{align*}
</span></p>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
重要
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>内積の結果はスカラー、ベクトル積の結果はベクトル</li>
<li><span class="math inline">\bm{v}\cdot \bm{v} = |\bm{v}|^2</span></li>
<li><span class="math inline">\bm{v}\times \bm{w}</span> は <span class="math inline">\bm{v}</span> と <span class="math inline">\bm{w}</span> の両方に垂直</li>
<li><span class="math inline">|\bm{v}\times \bm{w}|</span> は <span class="math inline">\bm{v},\bm{w}</span> の作る平行四辺形の面積に等しい <a href="fig/cross_prod.html" target="_blank">（イメージ）</a></li>
</ul>
</div>
</div>
</section>
</section>
<section id="次元空間での曲線曲面" class="level3" data-number="0.3">
<h3 data-number="0.3" class="anchored" data-anchor-id="次元空間での曲線曲面"><span class="header-section-number">0.3</span> ３次元空間での曲線・曲面</h3>
<section id="曲線" class="level4">
<h4 class="anchored" data-anchor-id="曲線">曲線</h4>
<p>２次元空間において原点を中心とする半径１の円は、方程式を使って <span class="math display">C: x^2+y^2=1</span> と表せた。 一方で、パラメータ表示を使うと、<span class="math inline">t</span> を実数パラメータとして <span class="math display">
x=\cos t, \quad y=\sin t, \quad 0\leq t \leq 2\pi
</span> と表すこともできた。 つまり、関数 <span class="math inline">\bm{r}</span> を以下のように定義したならば、 <span id="eq-rt"><span class="math display">
\bm{r}(t) = (\cos t, \sin t),\quad 0\leq t\leq 2\pi
\tag{1}</span></span></p>
<p><span class="math inline">\bm{r}</span> に <span class="math inline">t</span> を入力してたものである <span class="math inline">\bm{r}(t)</span> は円<span class="math inline">C</span>上の１点になり、 区間全体 <span class="math inline">[0, 2\pi]</span> を入力してたものである <span class="math inline">\bm{r}([0,2\pi])</span> は円<span class="math inline">C</span>そのものなる。 つまり、<span class="math inline">C=\bm{r}([0,2\pi])</span> と書ける。</p>
<p>イメージとしては、<span class="math inline">t</span> を時刻だと思い、<span class="math inline">\bm{r}(t)</span> は各時刻 <span class="math inline">t</span> での点の位置を表し、 <span class="math inline">\bm{r}([0,2\pi])</span> は時刻が <span class="math inline">0</span> から <span class="math inline">2\pi</span> の間に点が動く軌跡と思える。</p>
<p>ところで、式 (<a href="#eq-rt" class="quarto-xref">Equation&nbsp;1</a>) は <span class="math display">
\bm{r}: [0, 2\pi] \to \mathbb{R}^2,\quad t\mapsto (\cos t, \sin t),
</span> と書くこともできるので、以降は関数を表す際にこの形を主に使う。 （入力元：<span class="math inline">[0, 2\pi]</span>、　出力先：<span class="math inline">\mathbb{R}^2</span> で <span class="math inline">t</span> を入力すると <span class="math inline">(\cos t, \sin t)</span> を出力する、という意味。）</p>
<p>任意の関数 <span class="math display">\bm{r}: [a,b] \to \mathbb{R}^2,\quad t\mapsto (x(t), y(t))</span> にたいして、<span class="math inline">\bm{r}([a,b])</span> は曲線とみなすことができる。 さらにこの表記法だと３次元空間内の曲線でも同様の表し方ができる。</p>
<p>例：</p>
<ul>
<li><p><span class="math inline">\bm{r}: [0,1] \to \mathbb{R}^2,\quad t\mapsto (t, t^2)</span> としたとき、<br>
<span class="math inline">C=\bm{r}([0,1])</span> は２次元空間内の放物線 <span class="math inline">y=x^2, (0\leq x\leq 1)</span> を表している。</p></li>
<li><!-- [link](../fig/helix.html) -->
<p><span class="math inline">\bm{r}: [0,6\pi] \to \mathbb{R}^3,\quad t\mapsto (\cos t, \sin t, t)</span> としたとき、<br>
<span class="math inline">C=\bm{r}([0,6\pi])</span> は３次元空間内の螺旋のような曲線を表している。 <a href="fig/helix.html" target="_blank">螺旋状曲線</a></p></li>
<li><p><span class="math inline">\bm{r}: [0,1/2] \to \mathbb{R}^2,\quad t\mapsto (2t, 4t^2)</span> としたとき、<br>
<span class="math inline">C=\bm{r}([0,1/2])</span> は２次元空間内の放物線 <span class="math inline">y=x^2, (0\leq x\leq 1)</span> を表している。</p></li>
<li><p><span class="math inline">\bm{r}: [0,1] \to \mathbb{R}^2,\quad t\mapsto (1-t, (1-t)^2)</span> としたとき、<br>
<span class="math inline">C=\bm{r}([0,1])</span> は２次元空間内の放物線 <span class="math inline">y=x^2, (0\leq x\leq 1)</span> を表している。</p></li>
</ul>
<p>３番目と４番目は１番目と同じ曲線であり、つまり異なる関数 <span class="math inline">\bm{r}</span> が同じ曲線を表すことは起こる。</p>
<!-- ![alt text](fig/spiral.png) -->
<!-- ![Interactive Plot](fig/spiral.html) -->
<!-- ![alt text](fig/spiral.svg) -->
<!-- [螺旋曲線](/fig/spiral.html). -->
<!-- 
例：関数の表す曲線

* 区間は $(-\infty, \infty)$、つまり $\RR$ 全体として $$\bm{r}: \RR \to \RR^2,\quad t \mapsto (t, 2t)$$ としたならば、これは直線 $y=2x$ を表す。

         
- 区間は $\RR$ 全体として
$$\bm{r}: \RR \to \RR^2,\quad t \mapsto (t, t^2)$$
としたならば、これは放物線 $y=x^2$ を表す。

- 区間は $\RR$ 全体として
$$\bm{r}: \RR \to \RR^2,\quad t \mapsto (2t, 4t^2)$$
としたならば、これも放物線 $y=x^2$ を表す。（つまり、異なる関数が同じ曲線を表すこともある。）
 -->
<!-- 
::: {.callout-note} 
３次元空間の曲線 同様に、関数 $\bm{r}: [a,b] \to \RR^3$ が与えられれば、３次元空間の曲線を表しているとみなすことができる。
:::
 -->
<!-- 
##### 弧長（曲線の長さ）

* 曲線がパラメータで表されているとき $f: \RR \to \RR^2,\quad t \mapsto (x(t), y(t))$
* 曲線が方程式で表されているとき $F(x,y)=0$
 -->
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
曲線の長さ
</div>
</div>
<div class="callout-body-container callout-body">
<p><a id="thm:arc-2d-1" href=""></a> <span class="math inline">t</span> が区間 <span class="math inline">[a, b], (a \leq b)</span> を動く間に点 <span class="math inline">\bm{r}(t)=(x(t), y(t), z(t))</span> が動く走行距離は <span class="math display">
\int_a^b \sqrt{ x'(t)^2 + y'(t)^2+ z'(t)^2}\, dt
\left(= \int_a^b |\bm{r}'(t)|\, dt\right).
</span> 特に、もし同じ点を通るようなことがなければ上は曲線の長さ（弧長）を意味する。</p>
</div>
</div>
<p>これ以降は、上の公式が曲線の長さ（弧長）になるような曲線のみを考える。</p>
<p>その状況では <span class="math inline">t</span> が変化するにつれて点 <span class="math inline">\bm{r}(a)</span> から <span class="math inline">\bm{r}(t)</span> までの弧長は 常に（連続的に）変化してゆく。 したがって、<span class="math inline">t</span> の値とその弧長は１対１で対応しているので、 <span class="math inline">t</span> の代わりに弧長をパラメータとして曲線の位置が定まる。</p>
<!-- 
ここまで、曲線を表すパラメータとして $t$ を使ってきたが、特に $t$ に対し条件はなかった。
しかし、パラメータの値が曲線の（ある基準点からの）長さに一致するようなものならば便利なことも多い。
 -->
<p>そのようなパラメータを <span class="math inline">s</span> を使って表すことが多い。 そのとき、<span class="math inline">s</span> は <span class="math inline">t</span> の関数とみることができ、 上の公式より <span class="math display">
s(t) = \int_a^t \sqrt{ x'(t)^2 + y'(t)^2+ z'(t)^2}\, dt
</span> と書くことができる。上で述べた通り <span class="math inline">t</span> と <span class="math inline">s</span> は１対１で対応しているので、 何らかの関数 <span class="math inline">\phi</span> を使って <span class="math display">
t = \phi(s)
</span> と書ける（この関数は必ずしもきれいに求まらない）。 よって、 改めて点の位置を <span class="math inline">\bm{r}(\phi(s))</span> で表せば、 その点までの弧長が常に <span class="math inline">s</span> に一致し、便利なことも多い。</p>
<!-- 
$$
s(t) = \int_0^t \sqrt{ x'(t)^2 + y'(t)^2+z'(t)^2}\, dt \Longrightarrow \frac{ds}{dt}=\sqrt{ x'(t)^2 + y'(t)^2+z'(t)^2}.
$$
 -->
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="math inline">s</span> をパラメータとした表示
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">\bm{r}(t), a\leq t\leq b</span> によって曲線上の位置が表されているとし、 点 <span class="math inline">\bm{r}(a)</span> からの弧長が <span class="math inline">s</span> になるような曲線上の位置を <span class="math inline">\bm{\rho}(s)</span> とする。 このとき <span class="math inline">t=\phi(s)</span> と書けるならば <span class="math display">
\bm{\rho}(s)=\bm{r}(\phi(s))
</span> となる。</p>
</div>
</div>
<p>例：<span class="math inline">\bm{r}(t)=(2\cos t, 2\sin t)</span>, <span class="math inline">0\leq t &lt; 2\pi</span> ならば <span class="math display">
s= \int_0^t \sqrt{4\cos^2 t + 4\sin^2 t}\, dt = \int_0^t 2\,dt=2t \Longrightarrow t=\frac{s}{2}
</span> であり、よって <span class="math display">
\bm{\rho}(s) = \bm{r}(s/2)=\left(2\cos\frac{s}{2}, 2\sin\frac{s}{2}\right).
</span></p>
<p>たしかに点 <span class="math inline">\bm{\rho}(0)</span> から点 <span class="math inline">\bm{\rho}(s)</span> までの弧長は常に <span class="math inline">s</span> になっている。</p>
<!-- ---

しかし、両辺を $t$ で微分することにより、
$$
\frac{ds}{dt}=\sqrt{ x'(t)^2 + y'(t)^2+z'(t)^2}=|\bm{r}'(t)|.
$$
という関係式は得られる。

--- -->
<hr>
<p>ここでの話は弧長をパラメータとして使うほうが、簡明なのでそれを用いる。</p>
<section id="接線ベクトル法線ベクトル曲率捩率" class="level5">
<h5 class="anchored" data-anchor-id="接線ベクトル法線ベクトル曲率捩率">接線ベクトル・法線ベクトル・曲率・捩率</h5>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
接線ベクトル、曲率
</div>
</div>
<div class="callout-body-container callout-body">
<p>曲線上の点の位置を、弧長 <span class="math inline">s</span> をパラメータとして使って、 <span class="math inline">\bm{r}(s)</span> とする。 その位置での単位接線ベクトル <span class="math inline">\bm{T}(s)</span>、曲率 <span class="math inline">\kappa(s)</span> を次のように定義する： <span class="math display">
    \bm{T}(s):=\frac{d \bm{r}(s)}{ds},\quad \kappa(s):=\left|\frac{d\bm{T}(s)}{ds}\right|
    </span></p>
</div>
</div>
<!-- 
::: callout-note 
## 接線ベクトル、曲率 
曲線上の点の位置を $\bm{r}(t)$ とする。その位置での単位接線ベクトル $\bm{T}(t)$、曲率 $\kappa(t)$ を定義する： 
$$
\bm{T}(t):=\frac{\bm{r}'(t)}{|\bm{r}'(t)|},\quad \kappa(t):=\left|\frac{\bm{T}'(t)}{\bm{r}'(t)}\right|
$$
:::
 -->
<p>単位接線ベクトルは <span class="math inline">\bm{r}(s)</span> が描く曲線上の各点における接線の方向のベクトルになっている。（大きさは１で、向きは <span class="math inline">s</span> が増加するときに点が動く方向。）</p>
<!-- 
$\bm{T}'(s)\cdot \bm{T}(s) = (\bm{T}(s)\cdot \bm{T}(s))'/2 = 0$ より $\bm{T}'(s)$ と $\bm{T}(s)$ は垂直であることに注意すると、
 -->
<p>曲率はおおまかに言って、各々の位置で、曲線を円で近似した時の円の半径の逆数となる。 つまり、曲率が大きいということはその円の半径は小さいということであり、 その位置での曲がり具合は大きくなる。</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
法線ベクトル、従法線ベクトル、捩率
</div>
</div>
<div class="callout-body-container callout-body">
<p>曲線上の点の位置を <span class="math inline">\bm{r}(s)</span> とする。その位置での単位法線ベクトル <span class="math inline">\bm{N}(s)</span>、従法線ベクトル <span class="math inline">\bm{B}(s)</span>、捩率 <span class="math inline">\tau(s)</span> を定義する： <span class="math display">
\bm{N}(s):=\frac{1}{\kappa (s)}\frac{d \bm{T}(s)}{ds},\quad \bm{B}(s):= \bm{T}(s) \times \bm{N}(s),\quad {\tau}(s):=-\bm{N}(s) \cdot \frac{d\bm{B}(s)}{ds}.
</span></p>
</div>
</div>
<!-- 
::: callout-note 
## 法線ベクトル、従法線ベクトル、捩率 
$\bm{r}(t)$ とする。その位置での単位法線ベクトル $\bm{N}(t)$、従法線ベクトル $\bm{B}(t)$、捩率 $\tau(t)$ を定義する： 
$$
\bm{N}(t):=\frac{\bm{T}'(t)}{|\bm{T}'(t)|},\quad \bm{B}(t):= \bm{T}(t) \times \bm{N}(t),\quad \bm{\tau}(t):=-\bm{N}(t) \cdot \bm{B}'(t).
$$
:::
 -->
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Frenet-Serret の公式
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math display">
\begin{align*}
    \bm{T}' &amp;= \kappa \bm{N},\\
    \bm{B}' &amp;= -\tau \bm{N},\\
    \bm{N}' &amp;= -\kappa\bm{T} + \tau\bm{B}.
\end{align*}
</span></p>
</div>
</div>
<p>１つ目と２つ目は上の定義からすぐにわかる。 （２つ目を満たす <span class="math inline">\tau</span> を捩率の定義とすることも多い。） ３つ目は <span class="math inline">(\bm{T}, \bm{N}, \bm{B})</span> が右手系の正規直交基底を成すこと を使って微分の計算をすると言える。</p>
<!-- 


You can jump to [定理](#thm:arc-2d-1) for more information.


 -->
</section>
</section>
<section id="曲面" class="level4">
<h4 class="anchored" data-anchor-id="曲面">曲面</h4>
<p>曲線 <span class="math inline">C</span> は区間 <span class="math inline">[a, b] \subset \mathbb{R}</span> にたいしての関数 <span class="math inline">\bm{r}: [a,b] \to \mathbb{R}^3</span> によって <span class="math inline">C=\bm{r}([a,b])</span> と表していたが、</p>
<p>曲面 <span class="math inline">S</span> は領域 <span class="math inline">D \subset \mathbb{R}^2</span> にたいしての関数 <span class="math inline">\bm{r}: D \to \mathbb{R}^3</span> によって <span class="math inline">S=\bm{r}(D)</span> と表すことができる。</p>
<p>例：</p>
<ul>
<li><p>平面 (<span class="math inline">z=x+y</span>) の一部</p>
<p><span class="math inline">D=\{(u,v);\ 0\leq u \leq 1,\ 0\leq v\leq1 \}</span>,<br>
<span class="math inline">\bm{r}(u,v)=(u, v, u+v)</span></p></li>
<li><p>球面 (<span class="math inline">x^2+y^2+z^2=1</span>)</p>
<p><span class="math inline">D=\{(u,v);\ 0\leq u&lt;\pi,\ 0\leq v&lt;2\pi\}</span>,<br>
<span class="math inline">\bm{r}(u,v)=(\sin u \cos v,\ \sin u \sin v,\ \cos u)</span></p></li>
<li><p><a href="fig/mobius_strip.html" target="_blank">メビウスの帯</a></p>
<p><span class="math inline">D=\{(u,v);\ 0\leq u&lt;2\pi,\ -1 \leq  v&lt;1 \}</span>,<br>
<span class="math inline">\bm{r}(u,v)=((1 + v \cos(u/2)) \cos u,\ (1 + v \cos(u/2)) \sin u,\ v \sin (u/2))</span></p></li>
</ul>
<!-- 
**曲面の面積**

曲面 $S: f(D), D \subset \RR^2.$

$$
A = \int_S \, d\sigma
= \int_S \sqrt{(dydz)^2+(dzdx)^2+(dxdy)^2}\\
= \int_S \sqrt{\left(\frac{dz}{dx}\right)^2 + \left(\frac{dz}{dy}\right)^2+1}\, dxdy
$$

曲面に沿って（$x,y$のそれぞれ一方を固定して）点を動かしたときの移動する範囲の面積を$\Delta \sigma$とすると、 それは平行四辺形で近似できるので 
$$
\Delta \sigma \approx 
|(0, \Delta y, \Delta z) \times (\Delta x, 0, \Delta z)|
=|(\Delta y \Delta z, \Delta z \Delta x, -\Delta x \Delta y)|
$$
 -->
<!-- $\eqref{eq}$ -->
<!-- $$x=y+1 \tag{1} \label{eq1}$$ -->
<!-- $$y=z\label{eq1}$$ -->
<!-- #### 座標系 (coordinate system) -->
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
定義：球面座標（極座標）
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">\mathbb{R}^3</span> における点 <span class="math inline">P</span> の位置は通常の座標 <span class="math inline">(x,y,z)</span> を使って一意的に表すことができる。 一方で、以下の関係式を満たす <span class="math inline">(r, \theta, \phi)</span>を使ってもほぼ一意的に表すことができる。ただし、<span class="math inline">0&lt;r,\ 0\leq \theta&lt;\pi,\ 0\leq \phi &lt;2\pi</span> とする。 <span class="math display">\begin{align*}
    x &amp;= r\sin \theta \cos \phi\\
    y &amp;= r\sin\theta \sin \phi \\\
    z &amp;= r\cos \theta
    \end{align*}</span> この座標 <span class="math inline">(r, \theta, \phi)</span> を球面座標と呼ぶ。</p>
</div>
</div>
<p>例：通常の座標（直交座標）における点 <span class="math inline">P=(\sin \frac{\pi}{3}\cos\frac{\pi}{6}, \sin \frac{\pi}{3}\sin\frac{\pi}{6}, \cos\frac{\pi}{3})=(\frac{3}{4}, \frac{\sqrt{3}}{4},\frac{1}{2})</span> は球面座標においては <span class="math inline">(1, \frac{\pi}{3}, \frac{\pi}{6})</span> と表せる。</p>
<!-- 
::: callout-note 
## 定義：曲線座標
:::
 -->
</section>
</section>
<section id="微分積分" class="level3" data-number="0.4">
<h3 data-number="0.4" class="anchored" data-anchor-id="微分積分"><span class="header-section-number">0.4</span> 微分積分</h3>
<p>端的に言って、スカラー場は位置を入力すると、何らかの値（スカラー） を返す関数であり、 ベクトル場は位置を入力すると、何らかのベクトルを返す関数である。 ただし、まったくの無秩序なものを返す関数は想定しておらず、 ある種の自然な性質持った関数を想定している。 （例えば位置が近ければ返ってくるものも近いような性質） そのような状況では微分や積分が展開できると便利である。</p>
<section id="スカラー場ベクトル場-scalar-field-vector-field" class="level4">
<h4 class="anchored" data-anchor-id="スカラー場ベクトル場-scalar-field-vector-field">スカラー場・ベクトル場 (scalar field, vector field)</h4>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
定義
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong>スカラー場</strong>：<span class="math inline">\mathbb{R}^m \to \mathbb{R}</span> の関数のこと<br>
<strong>ベクトル場</strong>：<span class="math inline">\mathbb{R}^m \to \mathbb{R}^n</span> の関数のこと<br>
（空間内の点を入力したら、その位置での温度（スカラー）や力（ベクトル）を出力する関数というイメージ。）</p>
</div>
</div>
</section>
<section id="スカラー場ベクトル場の微分" class="level4">
<h4 class="anchored" data-anchor-id="スカラー場ベクトル場の微分">スカラー場・ベクトル場の微分</h4>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
定義：デル作用素 <span class="math inline">\nabla</span>（ナブラ）
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">x,y,z</span> を <span class="math inline">\mathbb{R}^3</span>の直交座標とする。それに対してベクトル（のような）作用素を定義する： <span class="math display">
    \nabla := \left(\frac{\partial}{\partial x},\ \frac{\partial}{\partial y},\ \frac{\partial}{\partial z}\right)
    = \frac{\partial}{\partial x} \mathbf{i}+ \frac{\partial}{\partial y} \mathbf{j}+ \frac{\partial}{\partial z} \mathbf{k}
    </span></p>
</div>
</div>
<p>例：スカラー場 <span class="math inline">f(x,y,z) = x+x^2y+z^3</span> にたいして、 <span class="math display">
\nabla f = \left(\frac{\partial f}{\partial x},\ \frac{\partial f}{\partial y},\ \frac{\partial f}{\partial z}\right) = (1+2xy, x^2, 3z^2).
</span></p>
<p>また、<span class="math inline">\nabla</span> はあたかもベクトルのようにも扱われる。</p>
<p>例：ベクトル場 <span class="math inline">\bm{F}(x,y,z)=(1+x^2, x+y, -z)</span> との内積をとると、 <span class="math display">
\nabla \cdot \bm{F} = \frac{\partial}{\partial x} (1+x^2) + \frac{\partial}{\partial y} (x+y)+ \frac{\partial}{\partial z} (-z) = 2x + 1 -1=2x.
</span></p>
<p>例：ベクトル場 <span class="math inline">\bm{F}(x,y,z)=(-y, x, 0)</span> とのクロス積をとると、 <span class="math display">
\nabla \times \bm{F} = \left( \frac{\partial}{\partial y} (0) - \frac{\partial}{\partial z} (x),\ \frac{\partial}{\partial z} (-y) - \frac{\partial}{\partial x} (0),\ \frac{\partial}{\partial x} (x) - \frac{\partial}{\partial y} (-y) \right)= (0,0,2).
</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
定義
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">(x,y,z)</span> を <span class="math inline">\mathbb{R}^3</span>の直交座標系とする。</p>
<p>スカラー場 <span class="math inline">{f}: \mathbb{R}^3 \to \mathbb{R}</span> にたいして次の関数を定義する：</p>
<ul>
<li><strong>勾配</strong> <span class="math inline">\operatorname{grad} f := \nabla f</span> <!-- f_x\, \mathbf{i} + f_y\, \mathbf{j} + f_z\, \mathbf{k} --></li>
</ul>
<p>ベクトル場 <span class="math inline">\bm{F}: \mathbb{R}^3 \to \mathbb{R}^3</span> にたいして次の関数を定義する：</p>
<!-- (x,y,z)\mapsto (A_x(x,y,z), A_y(x,y,z), A_z(x,y,z))$ にたいして次の関数を定義する： -->
<ul>
<li><p><strong>発散</strong> <span class="math inline">\operatorname{div} \bm{F} := \nabla \cdot \bm{F}</span> <!-- = (A_x)_x+ (A_y)_y + (A_z)_z$ --></p></li>
<li><p><strong>回転</strong> <span class="math inline">\operatorname{rot} \bm{F} := \nabla \times \bm{F}</span> （または <span class="math inline">\operatorname{curl}\bm{F}</span> とも書く） <!--     
= ((A_z)_y-(A_y)_z)\, \mathbf{i} + ((A_x)_z-(A_z)_x)\,\mathbf{j} + ((A_y)_x-(A_x)_y)\,\mathbf{k}
 --></p></li>
</ul>
</div>
</div>
</section>
<section id="スカラー場ベクトル場の積分" class="level4">
<h4 class="anchored" data-anchor-id="スカラー場ベクトル場の積分">スカラー場・ベクトル場の積分</h4>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
定義：線積分
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">f</span> をスカラー場としたとき、曲線 <span class="math inline">C=\bm{r}([a,b])</span> に沿った線積分を次の左辺のように書き、その意味を右辺で定義する： <span class="math display">
\int_C f\, |d\bm{r}| := \int_a^b f(\bm{r}(t))\, |\bm{r}'(t)|\, dt.
</span></p>
<p><span class="math inline">\bm{F}</span> をベクトル場としたとき、曲線 <span class="math inline">C=\bm{r}([a,b])</span> に沿った線積分を次の左辺のように書き、その意味を右辺で定義する： <span class="math display">
\int_C \bm{F}\cdot d\bm{r} := \int_a^b \bm{F}(\bm{r}(t))\cdot \bm{r}'(t)\, dt.
</span> （積分の中は内積を取っている。）</p>
</div>
</div>
<p>ここの左辺で出ている <span class="math inline">d\bm{r}</span> は <span class="math inline">\bm{r}</span> の微小変化について教えてくれるもの、程度の理解で良い。 少し詳しく言えば、それは直線で近似することによって教えてくれる。 つまり、<span class="math inline">t=t_0</span> のところの周辺で <span class="math inline">\bm{r}</span> の描く曲線を直線で近似すると <span class="math display">
\bm{r}(t) \approx \bm{r}(t_0) + \bm{r}'(t_0)\,(t-t_0)
</span> であるので、<span class="math inline">t</span> の変化量が <span class="math inline">h</span> のとき <span class="math inline">\bm{r}</span> の変化量は <span class="math inline">\bm{r}'(t_0)\,h</span> で近似できる。そこで関数として <span class="math inline">d\bm{r}</span> を <span class="math display">
d\bm{r}: h \mapsto \bm{r}'(t)\,h
</span> と定義すれば、これは <span class="math inline">\bm{r}</span> の <span class="math inline">t</span> での微小変化についての情報を持っていると言える。 （<span class="math inline">t_0</span> は任意なので、改めて一般の <span class="math inline">t</span> での形とした。） 一方で <span class="math inline">dt</span> も関数だとみれば <span class="math display">
dt: h \mapsto h
</span> なので、関数として <span class="math inline">d\bm{r}=\bm{r}'(t)\, dt</span> であり、正に右辺に出てくる形になる。 また文献によっては <span class="math inline">|d\bm{r}|</span> のことを <span class="math inline">ds</span> と書くことも多く、これを線素と呼ぶ。</p>
<p>なぜならば、多くの場合 <span class="math inline">s</span> を曲線の長さだと思って使っており、その場合上の弧長の公式から <span class="math display">
s = \int_a^t \sqrt{x'(t)^2+y'(t)^2+z'(t)^2}\, dt
=\int_a^t \left|\frac{d\bm{r}}{dt}\right|\,dt
</span> であり、これの両辺を微分して <span class="math inline">\frac{ds}{dt} = \left|\frac{d\bm{r}}{dt}\right|</span> となるからである。</p>
<p>例：</p>
<ul>
<li><p><span class="math inline">\bm{r}(t)=(x(t), y(t)), x(t)=\cos t, y(t)=\sin t, C=\bm{r}([0, \pi]), f=1</span> とすると <span class="math display">
\bm{r}'(t)=(x'(t), y'(t))=(-\sin t, \cos t).</span> <span class="math display">
\int_0^{\pi} f(\bm{r}(t))\, |\bm{r}'(t)|\,dt = \int_0^{\pi} \sqrt{x'(t)^2+y'(t)^2}\,dt = \pi.
</span></p></li>
<li><p><span class="math inline">\bm{r}(t)=(x(t), y(t)), x(t)=\cos (\pi-t), y(t)=\sin (\pi-t), C=\bm{r}([0, \pi]), f=1</span> とすると <span class="math display">
\bm{r}'(t)=(x'(t), y'(t))=(\sin (\pi-t), -\cos (\pi-t)).</span> <span class="math display">
  \int_0^{\pi} f(\bm{r}(t))\, |\bm{r}'(t)|\,dt = \int_0^{\pi} \sqrt{x'(t)^2+y'(t)^2}\,dt = \pi.
</span></p></li>
</ul>
<p>上の２つの例ではスカラー場 <span class="math inline">f</span> は同じであり、曲線 <span class="math inline">C</span> も同じものである。（表し方 <span class="math inline">\bm{r}</span> は違うが。） そのとき線積分の結果は同じになっている。 これは一般に成り立つことであり、線積分はスカラー場と曲線のみから決まる。 一方、下の２つの例はベクトル場の場合であり、このときは厳密にはベクトル場と曲線のみからは決まらず、曲線の “向き” も加味した値となる。</p>
<ul>
<li><p><span class="math inline">x(t)=\cos t, y(t)=\sin t, C=\bm{r}([0, \pi]), \bm{F}(x,y)=(-y, x)</span> とすると <span class="math display">
\int_0^{\pi} \bm{F}(\bm{r}(t))\cdot \bm{r}'(t)\,dt = \int_0^{\pi} \{-y(t) x'(t)+x(t)y'(t)\}\,dt = \int_0^{\pi} (\sin^2 t + \cos^2 t)\, dt=\pi.
</span></p></li>
<li><p><span class="math inline">x(t)=\cos (\pi-t), y(t)=\sin (\pi-t), C=\bm{r}([0, \pi]), \bm{F}(x,y)=(-y, x)</span> とすると <span class="math display">
  \bm{F}(t) = (-\sin(\pi-t), \cos(\pi-t)),\quad \bm{r}'(t) = (\sin(\pi-t), -\cos(\pi-t)).
</span> <span class="math display">
  \begin{align*}
  \int_0^{\pi} \bm{F}(\bm{r}(t))\cdot \bm{r}'(t)\,dt &amp;= \int_0^{\pi} \{-y(t) x'(t)+x(t)y'(t)\}\,dt \\ &amp;= -\int_0^{\pi} (\sin^2(\pi- t) + \cos^2 (\pi-t))\, dt=-\pi.
  \end{align*}
</span></p></li>
</ul>
<!--
::: {.callout-caution} 
## 注意 
$s$ の定義を始点（$t$ の始点に対応する点）からの長さとすると、 $ds/dt$ は $C$ の向きに依存する。 $s$ の定義をあらかじめ固定された１点からの長さとすると、 $ds/dt$ は $C$ の向きに依存しないが、その点を境に符号が変わる。
:::
-->
<!-- 
::: callout-note 
## 定義：線積分
    $f$ をスカラー場としたとき、曲線 $C=\bm{r}([a,b])$ に沿った線積分を次の右辺で定義する：
    $$\int_C f\, ds := \int_a^b f(\bm{r}(t))\, \frac{ds}{dt}\, dt.$$
    $$\int_C f\, |d\bm{r}| := \int_a^b f(\bm{r}(t))\, \left|\frac{d\bm{r}}{dt}\right|\, dt.$$
    $\bm{F}$ をベクトル場としたとき、曲線 $C=\bm{r}([a,b])$ に沿った線積分を次の右辺で定義する：
    $$\int_C \bm{F}\cdot d\bm{r} := \int_a^b \bm{F}(\bm{r}(t))\cdot \frac{d\bm{r}}{dt}\, dt.$$
    （積分の中身は内積を取っている。）
::: 
-->
<!-- 
スカラー場の線積分はパラメータ化の仕方によらないと説明されることが多いが、それは $t$ の動く向きによって $s$ も変わるからである。要するに、$t$ が大➝小の向きになると、$ds/dt$ の符号が負になる。（$s$ というものが、$t$ がどう変化しようが常に増えるように定義されている。そのせいで $ds$ は 1-form にならない。）
 -->
<!-- 
例：$\bm{r}(t)= (t, t)$ とする。
* $t: 0\to 1$ と見るならば $s=\sqrt{2}t+c$ であり $ds/dt \geq 0$

* $t: 1\to 0$ と見るならば $s=-\sqrt{2}t+c$ であり $ds/dt\leq 0$
 -->
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>ベクトル場が力を表す場合、ベクトル場の線積分は、経路に沿って移動する力によって行われる仕事を表す。</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
定義：面積分
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">f</span> を <span class="math inline">\mathbb{R}^3</span> におけるスカラー場 とし、<span class="math inline">D\subset \mathbb{R}^2</span> としたとき、 曲面 <span class="math inline">S=\bm{r}(D)\subset \mathbb{R}^3</span> に沿った面積分を次の左辺のように書き、その意味を右辺で定義する： <!-- $$\int_S f\, |d^2 \bm{r}| := \int_D f(\bm{r}(u, v))\, |\bm{T}_u \times \bm{T}_v|\, dudv.$$ --> <span class="math display">
\int_S f\, |d \bm{A}| := \int_D f(\bm{r}(u, v))\, |\bm{r}_u \times \bm{r}_v|\, dudv.
</span></p>
<p><span class="math inline">\bm{F}</span> を <span class="math inline">\mathbb{R}^3</span> におけるベクトル場 とし、<span class="math inline">D\subset \mathbb{R}^2</span> としたとき、 曲面 <span class="math inline">S=\bm{r}(D)\subset \mathbb{R}^3</span> に沿った面積分を次の左辺のように書き、その意味を右辺で定義する： <span class="math display">
\int_S \bm{F}\cdot d \bm{A} := \int_D \bm{F}(\bm{r}(u, v))\, \cdot (\bm{r}_u \times \bm{r}_v)\, dudv.
</span> ここでは <span class="math inline">\bm{r}_u:=\frac{\partial \bm{r}}{\partial u}, \bm{r}_v:= \frac{\partial \bm{r}}{\partial v}</span> と定義する。</p>
</div>
</div>
<!-- ================================================ -->
<!-- 

曲線 $C=f([t_0, t_1])$.

$$
L = \int_C \, ds
= \int_C \sqrt{(dx)^2+(dy)^2}
= \int_{t_0}^{t_1} \sqrt{\left(\frac{dx}{dt}\right)^2 + \left(\frac{dy}{dt}\right)^2}\, dt
% = \int_{t_0}^{t_1} \left|\frac{df}{dt}\right|\, dt
$$

注：曲線に沿って点を動かしたときの移動量を$\Delta s$ とすると、 $x,y$ のそれぞれの変化量を$\Delta x, \Delta y$ と書くならば、近似式 \$ \Delta s \approx \|(\Delta x, \Delta y)\| = \sqrt{(\Delta x)^2 +(\Delta y)^2} \$ が成り立つから。

$C$ が3次元空間にある曲線の場合は

$$
L = \int_C \, ds
= \int_C \sqrt{(dx)^2+(dy)^2+(dz)^2}
= \int_{t_0}^{t_1} \sqrt{\left(\frac{dx}{dt}\right)^2 + \left(\frac{dy}{dt}\right)^2 + \left(\frac{dz}{dt}\right)^2}\, dt
% = \int_{t_0}^{t_1} \left|\frac{df}{dt}\right|\, dt
$$

**線積分**

曲線 $C: f([t_0, t_1])$上のスカラー関数 $\phi: C\to\RR$

$$
\int_C \phi \, ds
= \int_C \phi \sqrt{(dx)^2+(dy)^2}
= \int_{t_0}^{t_1} \phi(x(t), y(t)) \sqrt{\left(\frac{dx}{dt}\right)^2 + \left(\frac{dy}{dt}\right)^2}\, dt
% = \int_{t_0}^{t_1} \left|\frac{df}{dt}\right|\, dt
$$

**面積分**

 -->
<!-- ================================================ -->
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
定理：Stokes の定理
</div>
</div>
<div class="callout-body-container callout-body">
<p>曲面 <span class="math inline">S \subset \mathbb{R}^3</span> がある境界曲線 <span class="math inline">C</span> で囲まれているとする。このときベクトル場 <span class="math inline">\bm{F}</span> に対して <span class="math display">
    \int_S \operatorname{rot}\bm{F} \, \cdot d\bm{A} = \int_{C} \bm{F}\cdot d\bm{r}.
</span> ただし、<span class="math inline">d\bm{A}</span> の指す方向から <span class="math inline">C</span> を見たとき半時計回りになるように右辺の線積分を取る。 <!-- 
$\omega \in \Omega_1$
$$
\int_S\, d\omega = \int_{\partial S} \omega
$$
 --></p>
</div>
</div>
<p>・・・</p>
<!-- 
例：例えば $\bm{r}=(x,y,z)$<!-- $x=x(u,v), y=y(u,v), z=z(u,v)$ 
と書き、$\bm{F}(x,y,z) =(F_1(x,y,z), F_2(x,y,z), F_3(x,y,z))$ と書くならば 左辺は
$$
\int_S \left(\frac{\partial F_3}{\partial y} - \frac{\partial F_2}{\partial z} \right)\, dydz  +  \left(\frac{\partial F_1}{\partial z} - \frac{\partial F_3}{\partial x} \right)\, dzdx  +  \left(\frac{\partial F_2}{\partial x} - \frac{\partial F_1}{\partial y} \right)\, dxdy.
$$ 
右辺は 
$$
\int_{\partial S} F_1\,dx + F_2\,dy + F_3\,dz.
$$
 -->
<!-- 
ベクトル場 $\bm{F}: \RR^3 \to \RR^3,\ (x,y,z)\mapsto (A_x(x,y,z), A_y(x,y,z), A_z(x,y,z))$ 
-->
<!-- $(x,y,z)\mapsto (A_x(x,y,z), A_y(x,y,z), A_z(x,y,z))$ -->
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
定理：Gauss の発散定理
</div>
</div>
<div class="callout-body-container callout-body">
<p>立体領域 <span class="math inline">V \subset \mathbb{R}^3</span> が閉曲面 <span class="math inline">S</span> で囲まれているとする。このときベクトル場 <span class="math inline">\bm{F}: \mathbb{R}^3 \to \mathbb{R}^3</span> に対して <span class="math display">
\iiint_{V} \operatorname{div}\bm{F}\, dxdydz= \int_{S} \bm{F}\cdot  d\bm{A}.
</span> ただし、<span class="math inline">S</span> 上で <span class="math inline">d\bm{A}</span> の指す方向が <span class="math inline">V</span> の外向きになるように右辺の面積分を取る。 <!-- 
$\omega \in \Omega_2$
$$
\int_V \,d \omega  = \int_{\partial V} \omega
$$
 --></p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
定理：Green の定理
</div>
</div>
<div class="callout-body-container callout-body">
<p>単連結な領域 <span class="math inline">D \subset \mathbb{R}^2</span> とベクトル場 <span class="math inline">\bm{F}: \mathbb{R}^2 \to \mathbb{R}^2,\ (x,y)\mapsto (P(x,y), Q(x,y))</span> に対して <span class="math display">
\int_D \left(\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y} \right)\, dxdy = \int_{\partial D} P\, dx + Q\, dy.
</span></p>
</div>
</div>
<!-- 
### 応用

#### 数値計算

#### Quaternions

#### Optimization
 -->
</section>
</section>
<section id="微分形式" class="level3" data-number="0.5">
<h3 data-number="0.5" class="anchored" data-anchor-id="微分形式"><span class="header-section-number">0.5</span> 微分形式</h3>
<p>・・・</p>
<!-- 
$$
\begin{align*}
&d^0: \Omega^0 \to \Omega^{1};\qquad f \mapsto df = \sum_i \frac{\partial f}{\partial x^i}\,dx^i \\
% = f_x\,dx + f_y\,dy + f_z\,dz\\
&d^1: \Omega^1 \to \Omega^{2}; \qquad f\,dx^i \mapsto df\wedge dx^i  \\
&d^n: \Omega^n \to \Omega^{n+1}; \qquad f\,dx^{i_1} \wedge dx^{i_2}\wedge \cdots \wedge dx^{i_n} \mapsto  df \wedge dx^{i_1} \wedge dx^{i_2}\wedge \cdots \wedge dx^{i_n} \\
\end{align*}
$$
 -->
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>